def get_protocol_name(proto_number : int, layer = "internet") -> str:
    """
    Return protocol name based on protocol number.

    Args:
        proto_number (INT): protocol number (IANA)

    Returns:
        protocol name
    """
    internet_protocol_mapping = {
        0: "HOPOPT",
        1: "ICMP",
        2: "IGMP",
        3: "GGP",
        4: "IP-in-IP",
        5: "ST",
        6: "TCP",
        7: "CBT",
        8: "EGP",
        9: "IGP",
        10: "BBN-RCC-MON",
        11: "NVP-II",
        12: "PUP",
        13: "ARGUS",
        14: "EMCON",
        15: "XNET",
        16: "CHAOS",
        17: "UDP",
        18: "MUX",
        19: "DCN-MEAS",
        20: "HMP",
        21: "PRM",
        22: "XNS-IDP",
        23: "TRUNK-1",
        24: "TRUNK-2",
        25: "LEAF-1",
        26: "LEAF-2",
        27: "RDP",
        28: "IRTP",
        29: "ISO-TP4",
        30: "NETBLT",
        31: "MFE-NSP",
        32: "MERIT-INP",
        33: "DCCP",
        34: "3PC",
        35: "IDPR",
        36: "XTP",
        37: "DDP",
        38: "IDPR-CMTP",
        39: "TP++",
        40: "IL",
        41: "IPv6",
        42: "SDRP",
        43: "IPv6-Route",
        44: "IPv6-Frag",
        45: "IDRP",
        46: "RSVP",
        47: "GRE",
        48: "DSR",
        49: "BNA",
        50: "ESP",
        51: "AH",
        52: "I-NLSP",
        53: "SWIPE",
        54: "NARP",
        55: "MOBILE",
        56: "TLSP",
        57: "SKIP",
        58: "ICMPv6",
        59: "IPv6-NoNxt",
        60: "IPv6-Opts",
        61: "Any host internal protocol",
        62: "CFTP",
        63: "Any local network",
        64: "SAT-EXPAK",
        65: "KRYPTOLAN",
        66: "RVD",
        67: "IPPC",
        68: "Any distributed file system",
        69: "SAT-MON",
        70: "VISA",
        71: "IPCV",
        72: "CPNX",
        73: "CPHB",
        74: "WSN",
        75: "PVP",
        76: "BR-SAT-MON",
        77: "SUN-ND",
        78: "WB-MON",
        79: "WB-EXPAK",
        80: "ISO-IP",
        81: "VMTP",
        82: "SECURE-VMTP",
        83: "VINES",
        84: "TTP",
        85: "NSFNET-IGP",
        86: "DGP",
        87: "TCF",
        88: "EIGRP",
        89: "OSPF",
        90: "Sprite-RPC",
        91: "LARP",
        92: "MTP",
        93: "AX.25",
        94: "IPIP",
        95: "MICP",
        96: "SCC-SP",
        97: "ETHERIP",
        98: "ENCAP",
        99: "Any private encryption scheme",
        100: "GMTP",
        101: "IFMP",
        102: "PNNI",
        103: "PIM",
        104: "ARIS",
        105: "SCPS",
        106: "QNX",
        107: "A/N",
        108: "IPComp",
        109: "SNP",
        110: "Compaq-Peer",
        111: "IPX-in-IP",
        112: "VRRP",
        113: "PGM",
        114: "Any 0-hop protocol",
        115: "L2TP",
        116: "DDX",
        117: "IATP",
        118: "STP",
        119: "SRP",
        120: "UTI",
        121: "SMP",
        122: "SM",
        123: "PTP",
        124: "ISIS over IPv4",
        125: "FIRE",
        126: "CRTP",
        127: "CRUDP",
        128: "SSCOPMCE",
        129: "IPLT",
        130: "SPS",
        131: "PIPE",
        132: "SCTP",
        133: "FC",
        134: "RSVP-E2E-IGNORE",
        135: "Mobility Header",
        136: "UDPLite",
        137: "MPLS-in-IP",
        138: "MANET",
        139: "HIP",
        140: "Shim6",
        141: "WESP",
        142: "ROHC",
        143: "Ethernet",
        144: "L2TPv3",
        145: "VRRPv3",
        146: "GTPv1",
        147: "GTPv2",
        148: "GTPv3",
        149: "MLD",
        150: "P2MP",
        151: "SPF",
        152: "DCCP",
        153: "MPTCP",
        154: "ARL",
        155: "RPL",
        156: "NSP",
        157: "ILM",
        158: "RDMAP",
        159: "IPV6-OPT",
        160: "TEST",
        161: "IETF",
        162: "HIP-DHT",
        163: "SNMP",
        164: "NETCONF",
        165: "BGP",
        166: "MPLS",
        167: "SDP",
        168: "DOT1Q",
        169: "FCoE",
        170: "VxLAN",
        171: "NVGRE",
        172: "MPLS-TP",
        173: "SPB",
        174: "TRILL",
        175: "MPLS-UDP",
        176: "RIPv2",
        177: "ISISv2",
        178: "LISP",
        179: "RPLv2",
        180: "LLC",
        181: "IS-IS",
        182: "MobileIPv6",
        183: "DCCP-TP",
        184: "SCTP-TP",
        185: "IPsecESP",
        186: "TLS",
        187: "SCTP-CTP",
        188: "SIP",
        189: "HTTP",
        190: "DNS",
        191: "P2P",
        192: "RTSP",
        193: "FTP",
        194: "SSH",
        195: "HTTPS",
        196: "SFTP",
        197: "TLSv1",
        198: "TLSv2",
        199: "TLSv3",
        200: "QUIC",
        201: "WebSocket",
        202: "IP-over-IPv6",
        203: "Bittorrent",
        204: "P2P-over-HTTP",
        205: "RemoteDesktop",
        206: "VNC",
        207: "RDP",
        208: "X11",
        209: "IRC",
        210: "VoIP",
        211: "SIPv2",
        212: "Bluetooth",
        213: "Zigbee",
        214: "WiFi",
        215: "CoAP",
        216: "MQTT",
        217: "LoRaWAN",
        218: "NB-IoT",
        219: "5G",
        220: "WiMAX",
        221: "LTE",
        222: "NB-Fi",
        223: "LoRa",
        224: "NB-IoT-NS",
        225: "MQTT-SN",
        226: "CoAP-over-UDP",
        227: "Modbus",
        228: "IEC-61850",
        229: "OPC-UA",
        230: "CAN",
        231: "I2C",
        232: "RS485",
        233: "EtherCAT",
        234: "Profinet",
        235: "Ethernet/IP",
        236: "Powerline",
        237: "UAVCAN",
        238: "WIFI-Direct",
        239: "Z-Wave",
        240: "Sigfox",
        241: "Thread",
        242: "Dash7",
        243: "Cen2",
        244: "Bluetooth-LE",
        245: "Zigbee3",
        246: "Xbee",
        247: "LoRaWAN2",
        248: "M-Bus",
        249: "MPTCP",
        250: "RPL6",
        251: "6LowPAN",
        252: "PSTN",
        253: "GSM",
        254: "UMTS",
        255: "Reserved"
    }

    ethernet_protocol_mapping = {
        2048: "IPv4",
        2054: "ARP",
        34525: "IPv6"
    }

    if(layer == "internet"):
        return internet_protocol_mapping.get(proto_number, proto_number)
    elif(layer == "ethernet"):
        return ethernet_protocol_mapping.get(proto_number, proto_number)
    else:
        return "Unknown"
